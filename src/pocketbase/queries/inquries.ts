import { queryOptions, mutationOptions } from "@tanstack/react-query";
import { Collections, type InquiryResponse, type ApartmentUnitsResponse, type PropertiesResponse, type OtpResponse } from "../types";
import { pb } from "..";
import type z from "zod";
import type { insertInquirySchema, updateInquiryStatusSchema, approveInquirySchema, rejectInquirySchema, createAccountSchema } from "../schemas/inquiry";
import { toast } from "sonner";

export const listInqueryQuery = (
    page: number,
    perPage: number,
    sort?: string,
) =>
    queryOptions({
        queryKey: [Collections.Inquiry, page, perPage, sort],
        queryFn: () =>
            pb
                .collection<InquiryResponse<{ unitInterested: ApartmentUnitsResponse<{ property: PropertiesResponse }> }>>(Collections.Inquiry)
                .getList(page, perPage, {
                    sort,
                    expand: "unitInterested.property"
                }),
    });

export const listInquiriesWithOtpQuery = (
    page: number,
    perPage: number,
    status?: string,
    sort?: string,
) =>
    queryOptions({
        queryKey: [Collections.Inquiry, 'with-otp', page, perPage, status, sort],
        queryFn: async () => {
            const filter = status ? `status = '${status}'` : '';
            return pb
                .collection<InquiryResponse<{ unitInterested: ApartmentUnitsResponse<{ property: PropertiesResponse }>, otp: OtpResponse }>>(Collections.Inquiry)
                .getList(page, perPage, {
                    filter,
                    expand: 'otp,unitInterested.property',
                    sort: sort || '-created',
                });
        },
    });

export const registerInquiryMutation = mutationOptions({
    mutationFn: async (data: z.infer<typeof insertInquirySchema>) => {
        // Check for duplicate email
        const existing = await pb
            .collection(Collections.Inquiry)
            .getFullList({
                filter: `email = '${data.email}'`,
            }) as InquiryResponse[];

        if (existing.length > 0) {
            throw new Error('An inquiry with this email already exists. Please verify your email or contact support');
        }

        // Create inquiry with default values
        const inquiry = await pb
            .collection(Collections.Inquiry)
            .create({
                ...data,
                status: 'pending',
                emailVerified: false,
                approval_status: 'pending',
            }) as InquiryResponse;

        // OTP will be auto-created via PocketBase hooks or needs to be created here
        // If not auto-created by hooks, create it:
        try {
            await pb.collection(Collections.Otp).create({
                inquiry: inquiry.id,
                // code and expiresAt will be auto-generated by Go hooks
            });
        } catch (err) {
            console.warn('OTP creation may have failed or already exists:', err);
        }

        return inquiry;
    },
});

export const updateInquiryStatusMutation = mutationOptions({
    mutationFn: async (data: z.infer<typeof updateInquiryStatusSchema>) => {
        return pb.collection(Collections.Inquiry).update(data.inquiryId, {
            status: data.status,
            rejectionReason: data.rejectionReason || null,
        });
    },
});

export const approveInquiryMutation = mutationOptions<
    InquiryResponse,
    Error,
    z.infer<typeof approveInquirySchema>
>({
    mutationFn: async (data) => {
        return pb
            .collection<InquiryResponse>(Collections.Inquiry)
            .update(data.inquiryId, {
                approval_status: 'approved',
                approval_notes: data.approval_notes || '',
            });
    },
    onSuccess: () => {
        toast.success('Inquiry Approved', {
            description: 'The inquiry has been approved successfully',
        });
    },
    onError: (err) => {
        toast.error('Failed to Approve Inquiry', {
            description: err.message,
        });
    },
});

export const rejectInquiryMutation = mutationOptions<
    InquiryResponse,
    Error,
    z.infer<typeof rejectInquirySchema>
>({
    mutationFn: async (data) => {
        return pb
            .collection<InquiryResponse>(Collections.Inquiry)
            .update(data.inquiryId, {
                approval_status: 'rejected',
                rejection_reason: data.rejection_reason,
            });
    },
    onSuccess: () => {
        toast.success('Inquiry Rejected', {
            description: 'The inquiry has been rejected',
        });
    },
    onError: (err) => {
        toast.error('Failed to Reject Inquiry', {
            description: err.message,
        });
    },
});

export const createAccountMutation = mutationOptions<
    { user_id: string; email: string; tenant_id: string; first_name: string; last_name: string; password: string },
    Error,
    z.infer<typeof createAccountSchema>
>({
    mutationFn: async (data) => {
        const response = await fetch('/api/inquiry/create-account', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Authorization': `Bearer ${pb.authStore.token}`,
            },
            body: new URLSearchParams({
                inquiryId: data.inquiryId,
            }),
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || 'Failed to create account');
        }

        return response.json();
    },
    onSuccess: (data) => {
        toast.success('Account Created Successfully', {
            description: `Account for ${data.first_name} ${data.last_name} has been created`,
        });
    },
    onError: (err) => {
        toast.error('Failed to Create Account', {
            description: err.message,
        });
    },
});