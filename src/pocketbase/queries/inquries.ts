import { queryOptions, mutationOptions } from "@tanstack/react-query";
import { Collections, type InquiryResponse, type ApartmentUnitsResponse, type PropertiesResponse, type OtpResponse } from "../types";
import { pb } from "..";
import type z from "zod";
import type { insertInquirySchema, updateInquiryStatusSchema } from "../schemas/inquiry";

export const listInqueryQuery = (
    page: number,
    perPage: number,
    sort?: string,
) =>
    queryOptions({
        queryKey: [Collections.Inquiry, page, perPage, sort],
        queryFn: () =>
            pb
                .collection<InquiryResponse<{ unitInterested: ApartmentUnitsResponse<{ property: PropertiesResponse }> }>>(Collections.Inquiry)
                .getList(page, perPage, {
                    sort,
                    expand: "unitInterested.property"
                }),
    });

export const listInquiriesWithOtpQuery = (
    page: number,
    perPage: number,
    status?: string,
    sort?: string,
) =>
    queryOptions({
        queryKey: [Collections.Inquiry, 'with-otp', page, perPage, status, sort],
        queryFn: async () => {
            const filter = status ? `status = '${status}'` : '';
            return pb
                .collection<InquiryResponse<{ unitInterested: ApartmentUnitsResponse<{ property: PropertiesResponse }>, otp: OtpResponse }>>(Collections.Inquiry)
                .getList(page, perPage, {
                    filter,
                    expand: 'otp,unitInterested.property',
                    sort: sort || '-created',
                });
        },
    });

export const registerInquiryMutation = mutationOptions({
    mutationFn: async (data: z.infer<typeof insertInquirySchema>) => {
        // Check for duplicate email
        const existing = await pb
            .collection(Collections.Inquiry)
            .getFullList({
                filter: `email = '${data.email}'`,
            }) as InquiryResponse[];

        if (existing.length > 0) {
            throw new Error('An inquiry with this email already exists. Please verify your email or contact support');
        }

        // Create inquiry with default values
        const inquiry = await pb
            .collection(Collections.Inquiry)
            .create({
                ...data,
                status: 'pending',
                emailVerified: false,
            }) as InquiryResponse;

        // OTP will be auto-created via PocketBase hooks or needs to be created here
        // If not auto-created by hooks, create it:
        try {
            await pb.collection(Collections.Otp).create({
                inquiry: inquiry.id,
                // code and expiresAt will be auto-generated by Go hooks
            });
        } catch (err) {
            console.warn('OTP creation may have failed or already exists:', err);
        }

        return inquiry;
    },
});

export const updateInquiryStatusMutation = mutationOptions({
    mutationFn: async (data: z.infer<typeof updateInquiryStatusSchema>) => {
        return pb.collection(Collections.Inquiry).update(data.inquiryId, {
            status: data.status,
            rejectionReason: data.rejectionReason || null,
        });
    },
});